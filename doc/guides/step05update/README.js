Ext.data.JsonP.step05update({"guide":"<h1 id='step05update-section-step.5-%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E6%9B%B4%E6%96%B0'>Step.5 データの更新</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/step05update-section-proxy-%E3%81%AE%E8%A8%AD%E5%AE%9A'>proxy の設定</a></li>\n<li><a href='#!/guide/step05update-section-%E7%B7%A8%E9%9B%86%E3%81%AE%E6%9B%B4%E6%96%B0'>編集の更新</a></li>\n<li><a href='#!/guide/step05update-section-%E8%BF%BD%E5%8A%A0'>追加</a></li>\n<li><a href='#!/guide/step05update-section-%E5%89%8A%E9%99%A4'>削除</a></li>\n<li><a href='#!/guide/step05update-section-%E3%82%AD%E3%83%A3%E3%83%B3%E3%82%BB%E3%83%AB'>キャンセル</a></li>\n<li><a href='#!/guide/step05update-section-advance%3A-%E5%88%A5%E3%81%AA%E6%96%B9%E6%B3%95'>Advance: 別な方法</a></li>\n</ol>\n</div>\n\n<p>このステップでは、ユーザーが変更したデータでサーバー側に更新をかけます。</p>\n\n<h2 id='step05update-section-proxy-%E3%81%AE%E8%A8%AD%E5%AE%9A'>proxy の設定</h2>\n\n<p><strong>app/model/List.js</strong></p>\n\n<pre><code>proxy: {\n    type: 'direct',\n    api: {\n        read: 'MyList.rpc.MyList.getList',\n        create: 'MyList.rpc.MyList.createData',\n        update: 'MyList.rpc.MyList.updateData',\n        destroy: 'MyList.rpc.MyList.removeData'\n    },\n    reader: {\n        type: 'json',\n        rootProperty: 'data'\n    },\n    writer: {\n        type: 'json'\n    }\n}\n</code></pre>\n\n<ul>\n<li><code>model</code> 単体での更新を設定</li>\n<li><code>proxy</code>\n\n<ul>\n<li><code>type</code>\n\n<ul>\n<li><code>'ajax'</code></li>\n<li><code>'rest'</code></li>\n<li><code>'direct'</code></li>\n</ul>\n</li>\n<li><code>api</code> コンフィグに CRUD それぞれのメソッドを設定</li>\n<li><code>reader</code></li>\n<li><code>writer</code></li>\n</ul>\n</li>\n</ul>\n\n\n<h2 id='step05update-section-%E7%B7%A8%E9%9B%86%E3%81%AE%E6%9B%B4%E6%96%B0'>編集の更新</h2>\n\n<p>Model のデータを変更した後 <code>save</code> メソッドを呼び出します。\n既存の Model の更新になるので <code>update</code> にセットしたメソッドが呼ばれます。</p>\n\n<p><strong>app/view/main/MainController.js</strong></p>\n\n<p>Edit ビューにつけた「登録」ボタンのイベントリスナーで、画面を変える前にデータを保存するロジックを付け加えます。</p>\n\n<pre><code>onSubmit: function() {\n    var me = this,\n        list = me.lookupReference('mylist'),\n        edit = me.lookupReference('myedit'),\n        data = edit.getViewModel().getData();\n\n    data.rec.save();\n    me.setActiveItem(list);\n},\n</code></pre>\n\n<ul>\n<li><code>save</code> メソッド</li>\n<li>ダーティマークが消える</li>\n<li>リロードしてもデータが変わっている</li>\n</ul>\n\n\n<h2 id='step05update-section-%E8%BF%BD%E5%8A%A0'>追加</h2>\n\n<p>新しいレコードを追加する時には、新しい Model のインスタンスを生成して、それをEdit の rec にセットしてあげます。</p>\n\n<p><strong>app/view/main/MainController.js</strong></p>\n\n<pre><code>onAddList: function() {\n    var me = this,\n        list = me.lookupReference('mylist'),\n        edit = me.lookupReference('myedit'),\n        vmodel = edit.getViewModel();\n\n    vmodel.setData({\n        rec: Ext.create('MyList.model.List')\n    });\n    edit.reset();\n    me.setActiveItem(edit);\n},\n</code></pre>\n\n<ul>\n<li>id がない状態を <code>phantom</code> といいます。</li>\n<li>その状態の時に <code>save</code> メソッドが呼ばれると、<code>create</code> にセットしたメソッドが呼び出されます。</li>\n<li>サーバー側のメソッドでは、新しいレコードを保存し、新しい id をセットしたレコードを返します。</li>\n<li>更新でも追加でも Model の <code>save</code> メソッドを呼ぶので、「登録」ボタンのリスナーの処理に変更はありません。</li>\n</ul>\n\n\n<h2 id='step05update-section-%E5%89%8A%E9%99%A4'>削除</h2>\n\n<p>レコードの削除を実装します。\nレコードを削除する場合は、Model の <code>erase</code> メソッドを実行します。</p>\n\n<p><strong>app/view/main/MainController.js</strong></p>\n\n<pre><code>onRemoveList: function() {\n    var me = this,\n        list = me.lookupReference('mylist'),\n        selected = list.getSelection();\n\n    if( selected.length &gt; 0 ) {\n        selected[0].erase();\n    }\n\n},\n</code></pre>\n\n<ul>\n<li><code>erase</code> メソッドは、サーバーに <code>destroy</code> のリクエストを送り、</li>\n<li>モデルのインスタンスを破棄します。</li>\n<li><p>ボタンの活性が変化するのも確認</p></li>\n<li><p><code>save</code> でも <code>erase</code> でも、Model は自分が所属しているストアを調べて、そこのリストの状態も変更します。</p></li>\n</ul>\n\n\n<h2 id='step05update-section-%E3%82%AD%E3%83%A3%E3%83%B3%E3%82%BB%E3%83%AB'>キャンセル</h2>\n\n<ul>\n<li>データバインディングされているのでユーザーがフォームを変更したら、その変更は即座に Model の内容も変更しています。</li>\n<li>キャンセルされたときには、それを元に戻す必要があります。</li>\n</ul>\n\n\n<p><strong>app/view/main/MainController.js</strong></p>\n\n<pre><code>onCancel: function() {\n    var me = this,\n        list = me.lookupReference('mylist'),\n        edit = me.lookupReference('myedit'),\n        rec = edit.getViewModel().getData().rec;\n\n    if( !rec || rec.phantom ) {\n        edit.reset();\n    } else {\n        rec.load(rec.get('id'));\n    }\n    me.setActiveItem(list);\n\n}\n</code></pre>\n\n<ul>\n<li>Model の <code>load</code> メソッドでサーバーから訂正前のデータを再取得しています。</li>\n</ul>\n\n\n<h2 id='step05update-section-advance%3A-%E5%88%A5%E3%81%AA%E6%96%B9%E6%B3%95'>Advance: 別な方法</h2>\n\n<ul>\n<li>Model のメソッドで 1件ごとに処理するのではなく、Store の単位で一括処理もできます。</li>\n<li>Store には、<code>add</code> / <code>remove</code> といったメソッドがあり、Store にレコードを追加、削除できます。</li>\n<li>Store のメンバーの Model を変更するとダーティな状態になります。</li>\n<li>proxy が正しくセッティングされている場合は、Store にいくつかの更新をかけた後で、Store の <code>sync</code> メソッドを呼び出すと、それらの変更をまとめてサーバーに送ってくれます。</li>\n<li>Store の getModifiedRecords や getRemovedRecords メソッドで、更新／削除されたレコードを取得できますので、自前で処理することも可能です。</li>\n<li>Ext JS 5 から導入された、Session を使う方法もあります。\n<a href=\"http://www.xenophy.com/sencha-blog/11334\">Ext JS 5 のデータパッケージ詳説</a>\nが参考になります。</li>\n</ul>\n\n","title":"Step.5 データの更新"});